Steps of what the engine does:
1. Instantiate Window object
    - initializes GLFW (GLFramework)
    - initializes GLEW (GL Extension Wrangler)
    - set event handlers (mouse/key/resize)
2. Initialize IMGUI
3. Register tests using 'test' class
    - the game loop with run one instance of a test at a time
    - tests can be switched during run-time
    - tests have methods to update and render
4. Main game loop

Main game loop:
1. Update delta time
2. Call 'update' method of current test
3. Call 'render' method of current test
4. Imgui::begin()
5. Call 'imguirender' method of current test
6. Imgui::end()
7. Imgui::render()
8. glfw pollevents, swapbuffer 

Testfps class:
    Held objects:
        Window reference
        Camera instance

        /* Environment */
        Shader unique_ptr
        Material instance
        Mesh unique_ptr
        Texture vector<unique_ptr>
        Mesh::Vertex vector of instance
        unsigned int vector

        /* Ground */
        Texture instance * 4
        Shader unique_ptr
        Material instance
        Mesh unique_ptr
        Mesh::Vertex vector of instances
        unsigned int vector

        /* LightSource */
        { /* these three makes up a Mesh */
            VertexArray unique_ptr
            VertexBuffer unique_ptr
            IndexBuffer unique_ptr
        }
        Shader unique_ptr
        LightSource instance * 2

        /* other */
        float - deltaTime
        float - moveSpeed
        Matrix - View
        Matrix - Proj
        Camera::cameraModeType - cameraMode

Mesh class:
    Held objects:
        vector<Vertex> reference
        vector<unsigned int> reference
        Material reference
        VertexArray unique_ptr
        VertexBuffer unique_ptr
        IndexBuffer unique_ptr
Window class:
    Held objects:
        width, height
        GLFWwindow pointer
        5* float corresponding to mouse position/zoom
        1024 bools array for key held down
    Functions:
        getters for all the above objects
        event handler functions for keys, mouse, scroll
        two setter function for how objects are drawn on the screen
    Functionality:
        init GLFW, GLEW
        glfwCreateWindow
        set callbacks

______End result_____
Light object
    - three types currently: point, directional, spot
Material object
    - each material has references to ambient/diffuse/specular/emission textures,
        which describe how light affects them
    - each material has a shininess factor
Model object:
    - array of meshes basically
    - optimally meshes can be reused and so multiple models could reuse the same mesh,
        in order to do this, each mesh needs their own model transformation matrix and when
        drawing the model, each mesh sets its shader uniforms
Texture object: they can be reused by multiple materials
    - currently there are two types: loaded from a file or a vector of 4 floats
    - if loaded from a file it has width, height, bpp, filepath
    - the vector of 4 floats are: rgba values
    - only common thing is bind/unbind
        - color version does nothing
        - textures that are loaded have GL_IDs
Mesh object:
    - each object is made out of:
        - array of vertices
        - array of indices
        - material
VertexArray object:
    - GL ID
    - VertexBuffer
    - Layout
VertexBuffer object:
    - GL ID
    - two types: static, dynamic
    - static can be passed in with specific data and size
    - dynamic only needs size and will be constructed on the go
IndexBuffer:
    - GL ID
    - needs specific data with size
Idea:
    a model can consist of multiple of the same meshes, so each model holds references
    to meshes and each maps to a new model transformation matrix
Window:

